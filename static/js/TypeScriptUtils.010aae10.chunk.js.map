{"version":3,"file":"static/js/TypeScriptUtils.010aae10.chunk.js","mappings":"6IACA,QAA4B,mCAA5B,EAAgI,mC,0BCIzH,MAAMA,EAAqC,CAChD,CACEC,MAAO,YACPC,KAAM,8EACNC,KAAK,q3BA+BP,CACEF,MAAO,iBACPC,KAAK,oJAAsJC,KAAK,0lBAmBlK,CACEF,MAAO,2BACPC,KAAK,iIACLC,KAAK,mxBA6BP,CACEF,MAAO,gBACPC,KAAM,6CACNC,KAAK,mdAiBP,CACEF,MAAO,iBACPC,KAAM,6CACNC,KAAK,gWAeP,CACEF,MAAO,iBACPC,KAAM,6CACNC,KAAK,qgBAkBP,CACEF,MAAO,mBACPC,KAAM,uEACNC,KAAK,sXAcP,CACEF,MAAO,0BACPC,KAAM,8EACNC,KAAK,+RAYP,CACEF,MAAO,mBACPC,KAAM,uEACNC,KAAK,wWAcP,CACEF,MAAO,qBACPC,KAAM,oFACNC,KAAK,g5BA+BP,CACEF,MAAO,mBACPC,KAAM,0CACNC,KAAK,gdAYP,CACEF,MAAO,mBACPC,KAAM,yDACNC,KAAK,oZAYP,CACEF,MAAO,oBACPC,KAAM,mEACNC,KAAK,mQ,2DClQT,MAyBA,EAzBwBC,KACtB,MAAMC,GAAKC,EAAAA,EAAAA,KACX,OACEC,EAAAA,EAAAA,KAAA,OAAKC,UAAWC,EAAiBC,UAC/BH,EAAAA,EAAAA,KAACI,EAAAA,EAAkB,CACjBC,KAAMA,KACJC,EAAAA,EAAAA,MAAAC,EAAAA,SAAA,CAAAJ,SAAA,EACEG,EAAAA,EAAAA,MAACE,EAAAA,EAAI,CAACC,MAAO,CAAEC,UAAW,UAAYC,QAAS,OAAQC,QAAQ,KAAIT,SAAA,CAAC,iBAElEH,EAAAA,EAAAA,KAAA,OAAKC,UAAWC,OAEjBT,EAAcoB,KAAKC,IAClBd,EAAAA,EAAAA,KAACe,EAAAA,EAAY,CACXC,OAAQlB,IAAOgB,EAAIpB,MAEnBuB,KAAMH,GADDA,EAAIpB,YAMjBwB,MAAOA,KAAMlB,EAAAA,EAAAA,KAACmB,EAAAA,EAAQ,CAACC,OAAOC,EAAAA,EAAAA,IAAc5B,QAE1C,C","sources":["webpack://dev-tools/./src/Pages/TypeScriptUtils/TypeScriptUtils.module.css?5818","Constant/TSUtils.ts","Pages/TypeScriptUtils/TypeScriptUtils.tsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"TypeScriptUtils_container__pF-RP\",\"subContainer\":\"TypeScriptUtils_subContainer__2QezN\",\"separator\":\"TypeScriptUtils_separator__ueX9q\"};","export interface IUtilsDescription {\n  title: string;\n  desc: string;\n  code: string;\n}\nexport const utilsExamples: IUtilsDescription[] = [\n  {\n    title: 'as const ',\n    desc: 'Preserve literal types, type inference, and use as an alternative to enums.',\n    code: `\n  // Define routes with 'as const' for literal types\n  const routes = {\n    home: '/',\n    admin: '/admin',\n    users: '/users',\n  } as const;\n\n  // Infer the type of 'routes' object\n  type TypeOfRoutes = typeof routes;\n\n  // Function to navigate to a specific route\n  const goToRoute = (route: TypeOfRoutes[keyof TypeOfRoutes]) => {\n    console.log('Navigating to:', route);\n    // Actual navigation logic goes here\n  };\n\n  // Call the 'goToRoute' function\n  goToRoute(routes.admin); // Navigating to: /admin\n  goToRoute(routes.users); // Navigating to: /users\n\n  // 'as const' preserves literal types, providing type safety\n  // Similar effect to enums but with more flexibility\n  // TypeOfRoutes is inferred as:\n  // type TypeOfRoutes = {\n  //   readonly home: \"/\";\n  //   readonly admin: \"/admin\";\n  //   readonly users: \"/users\";\n  // };\n  `,\n  },\n  {\n    title: 'keyof & typeof',\n    desc: `Explore the basics of TypeScript's keyof and typeof operators through a practical example showcasing secure property access and value assignment.`, code: `\n      // Define an object\n      const car = {\n        make: 'Toyota',\n        model: 'Camry',\n        year: 2022,\n      } as const;\n  \n      // Access a property using keyof and typeof\n      type CarKey = keyof typeof car; // Type: 'make' | 'model' | 'year'\n      type CarProperty = typeof car[CarKey]; // Type: 'Toyota' | 'Camry' | 2022\n  \n      // Usage\n      const carKey: CarKey = 'make'; // Allowed values: 'make', 'model', 'year'\n      const carProperty: CarProperty = car[carKey]; // Type inference based on carKey\n  \n      console.log('Car Property:', carProperty);\n      `,\n  },\n  {\n    title: 'Extending keyof & typeof',\n    desc: `Learn how to safely extend an object's properties while maintaining type safety using TypeScript's keyof and typeof operators.`,\n    code: `\n      // Base object\n      const basePerson = {\n        name: 'Alice',\n        age: 30,\n      } as const;\n  \n      // Extending the base object\n      const extendedPerson = {\n        ...basePerson,\n        city: 'Wonderland',\n      } as const;\n  \n      // Utility function to access property from object\n      function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n        return obj[key];\n      }\n  \n      // Usage\n      const name = getProperty(extendedPerson, 'name'); // Type: 'Alice'\n      const age = getProperty(extendedPerson, 'age');   // Type: 30\n      const city = getProperty(extendedPerson, 'city'); // Type: 'Wonderland'\n  \n      console.log('Name:', name);\n      console.log('Age:', age);\n      console.log('City:', city);\n      `,\n  }\n  ,\n  {\n    title: 'Partial<Type>',\n    desc: 'Make all properties of an object optional.',\n    code: `\n  interface User {\n    id: number;\n    name: string;\n    email: string;\n  }\n  \n  function updateUser(user: User, updates: Partial<User>): User {\n    return { ...user, ...updates };\n  }\n  \n  const user: User = { id: 1, name: 'Alice', email: 'alice@example.com' };\n  const updates = { name: 'Alice Smith' };\n  const updatedUser = updateUser(user, updates);\n  console.log(updatedUser); // { id: 1, name: 'Alice Smith', email: 'alice@example.com' }\n  `,\n  },\n  {\n    title: 'Readonly<Type>',\n    desc: 'Make all properties of an object readonly.',\n    code: `\n  interface User {\n    readonly id: number;\n    name: string;\n    email: string;\n  }\n  \n  function getUserById(id: number): Readonly<User> {\n    return { id, name: 'Alice', email: 'alice@example.com' };\n  }\n  \n  const user = getUserById(1);\n  user.name = 'Bob'; // Error: Cannot assign to 'name' because it is a read-only property.\n  `,\n  },\n  {\n    title: 'Required<Type>',\n    desc: 'Make all properties of an object required.',\n    code: `\n    interface User {\n      id?: number;\n      name?: string;\n      email?: string;\n    }\n    \n    function createUser(user: Required<User>): void {\n      console.log(user.id, user.name, user.email);\n    }\n    \n    const user = { id: 1, name: 'Alice', email: 'alice@example.com' };\n    createUser(user); // OK\n    \n    const incompleteUser = { name: 'Bob' };\n    createUser(incompleteUser); // Error: Property 'id' is missing in type '{ name: string; }' but required in type 'Required<User>'.\n    `,\n  },\n  {\n    title: 'Pick<Type, Keys>',\n    desc: 'Create a type containing a subset of the properties of another type.',\n    code: `\n    interface User {\n      id: number;\n      name: string;\n      email: string;\n      isAdmin: boolean;\n    }\n    \n    type UserWithoutAdmin = Pick<User, 'id' | 'name' | 'email'>;\n    \n    const user: UserWithoutAdmin = { id: 1, name: 'Alice', email: 'alice@example.com' };\n    console.log(user); // { id: 1, name: 'Alice', email: 'alice@example.com' }\n    `,\n  },\n  {\n    title: 'Exclude<Type, Excluded>',\n    desc: 'Exclude from a type all properties that are assignable to a specified type.',\n    code: `\n    type Pet = 'cat' | 'dog' | 'bird';\n    type Wild = 'lion' | 'tiger' | 'bear';\n    type Animals = Pet | Wild;\n    \n    type Domestic = Exclude<Animals, Wild>;\n    \n    const pets: Domestic[] = ['cat', 'dog', 'bird'];\n    console.log(pets); // ['cat', 'dog', 'bird']\n    `,\n  },\n\n  {\n    title: 'Omit<Type, Keys>',\n    desc: 'Create a type that omits a subset of the properties of another type.',\n    code: `\n    interface User {\n      id: number;\n      name: string;\n      email: string;\n      isAdmin: boolean;\n    }\n    \n    type UserWithoutAdmin = Omit<User, 'isAdmin'>;\n    \n    const user: UserWithoutAdmin = { id: 1, name: 'Alice', email: 'alice@example.com' };\n    console.log(user); // { id: 1, name: 'Alice', email: 'alice@example.com' }\n    `,\n  },\n  {\n    title: 'Record<Keys, Type>',\n    desc: 'Create a type with a set of properties as keys and a specified type as the value.',\n    code: `\n    type Animal = 'cat' | 'dog' | 'bird';\n    type Sound = 'meow' | 'woof' | 'tweet';\n    \n    type Sounds = Record<Animal, Sound>;\n    \n    const sounds: Sounds = {\n      cat: 'meow',\n      dog: 'woof',\n      bird: 'tweet',\n    };\n    \n    console.log(sounds); // { cat: 'meow', dog: 'woof', bird: 'tweet' }\n\n    //use key as type property\n\n    interface Book {\n        title: string;\n        author: string;\n      }\n      \n      const books: Record<string, Book> = {\n        '978-1408894624': { title: 'Harry Potter and the Philosopher's Stone', author: 'J.K. Rowling' },\n        '978-0316015844': { title: 'Twilight', author: 'Stephenie Meyer' },\n        '978-1501175466': { title: 'The Handmaid's Tale', author: 'Margaret Atwood' },\n      };\n      \n      const book = books['978-1408894624'];\n      console.log(book.title); // 'Harry Potter and the Philosopher's Stone'\n    `,\n  },\n  {\n    title: 'ReturnType<Type>',\n    desc: 'Get the return type of a function type.',\n    code: `\n        function getUser(id: number): { id: number; name: string; email: string } {\n          // Implementation omitted for brevity.\n          return { id, name: 'Alice', email: 'alice@example.com' };\n        }\n        \n        type User = ReturnType<typeof getUser>;\n        \n        const user: User = { id: 1, name: 'Alice', email: 'alice@example.com' };\n        console.log(user); // { id: 1, name: 'Alice', email: 'alice@example.com' }\n        `,\n  },\n  {\n    title: 'Parameters<Type>',\n    desc: 'Get the parameter types of a function type as a tuple.',\n    code: `\n    function createUser(name: string, email: string): { id: number; name: string; email: string } {\n      // Implementation omitted for brevity.\n      return { id: 1, name, email };\n    }\n    \n    type CreateUserParams = Parameters<typeof createUser>;\n    \n    const params: CreateUserParams = ['Alice', 'alice@example.com'];\n    console.log(params); // ['Alice', 'alice@example.com']\n    `,\n  },\n  {\n    title: 'NonNullable<Type>',\n    desc: 'Create a type that removes null and undefined from a union type.',\n    code: `\n    type User = { id: number; name: string; email?: string } | null | undefined;\n    type NonNullableUser = NonNullable<User>;\n    \n    const user: NonNullableUser = { id: 1, name: 'Alice' };\n    console.log(user); // { id: 1, name: 'Alice' }\n    `,\n  },\n];\n","import React from 'react';\nimport styles from './TypeScriptUtils.module.css';\nimport { HookListItem } from '../../Components/HooksList/HookListItem';\nimport { Text } from '../../Components/Text';\nimport { utilsExamples } from '../../Constant/TSUtils';\nimport { SideMenu } from '../../Components/SideMenu';\nimport { LayoutWithSideMenu } from '../../Components/LayoutWithSideMenu';\nimport { extractTitles } from '../../Helpers/Json';\nimport { useScrollToElementOnMount } from '../../Hooks/useScrollToElementOnMount';\n\nconst TypeScriptUtils = () => {\n  const id = useScrollToElementOnMount();\n  return (\n    <div className={styles.container}>\n      <LayoutWithSideMenu\n        Left={() => (\n          <>\n            <Text style={{ alignSelf: 'center' }} padding={'25px'} variant=\"h6\">\n              Utility Types\n              <div className={styles.separator} />\n            </Text>\n            {utilsExamples.map((val) => (\n              <HookListItem\n                active={id === val.title}\n                key={val.title}\n                item={val}\n              />\n            ))}\n          </>\n        )}\n        Right={() => <SideMenu items={extractTitles(utilsExamples)} />}\n      />\n    </div>\n  );\n};\nexport default TypeScriptUtils;\n"],"names":["utilsExamples","title","desc","code","TypeScriptUtils","id","useScrollToElementOnMount","_jsx","className","styles","children","LayoutWithSideMenu","Left","_jsxs","_Fragment","Text","style","alignSelf","padding","variant","map","val","HookListItem","active","item","Right","SideMenu","items","extractTitles"],"sourceRoot":""}