"use strict";(self.webpackChunkdev_tools=self.webpackChunkdev_tools||[]).push([[890],{87324:function(e,t,n){n.d(t,{U:function(){return _}});var o=n(1413),a=n(45987),r=n(29439),i=n(28381),s="HookListItem_container__EWT5F",c="HookListItem_card__RWoWn",u=n(68132),l=n(58708),d=n(15550),h=n(35105),f=n(69964),p=n(16042),m=n(99362),v=n(98215),b=n(11739),g=n(53071),y=n(7023),k=n(34108),w=n(15861),x=n(49517),S=n(54808);function T(){return(T=(0,w.Z)((0,k.Z)().mark((function e(t){var n,o;return(0,k.Z)().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:n=(0,x.Z)({template:"create-react-app-typescript",files:{"src/App.tsx":{content:t,isBinary:!1},"index.tsx":{content:S.f3,isBinary:!1},"package.json":{content:JSON.stringify({dependencies:{react:"^18.0.0","react-dom":"^18.0.0","react-scripts":"^5.0.0"},main:"/index.tsx",devDependencies:{}}),isBinary:!1}}}),o="https://codesandbox.io/api/v1/sandboxes/define?parameters=".concat(n),window.open(o,"_blank");case 3:case"end":return e.stop()}}),e)})))).apply(this,arguments)}var C=n(97798),E=n(60514),O=n(22046),A=n(3543),I=n(86467),Z=n(64931),j=n(40666),D=n(29343),L=function(e){var t=e.expanded,n=e.item,o=(0,i.useContext)(j.I).isDark;return(0,D.jsx)(C.Z,{in:t,timeout:"auto",children:(0,D.jsxs)(E.Z,{children:[(0,D.jsx)(O.Z,{style:{whiteSpace:"pre-line"},variant:"body1",children:n.desc}),(0,D.jsx)("div",{children:(0,D.jsx)(A.Z,{style:o?I.Z:Z.Z,showLineNumbers:!0,language:"javascript",children:n.code})})]})})},N=["expand"],_=function(e){var t=e.item,n=i.useState(!1),k=(0,r.Z)(n,2),w=k[0],x=k[1],S=function(){x(!w)},C=(0,u.ZP)((function(e){e.expand;var t=(0,a.Z)(e,N);return(0,D.jsx)(l.Z,(0,o.Z)({},t))}))((function(e){var t=e.theme;return{transform:e.expand?"rotate(180deg)":"rotate(0deg)",marginLeft:"auto",transition:t.transitions.create("transform",{duration:t.transitions.duration.shortest})}}));return(0,D.jsx)("div",{className:s,children:(0,D.jsxs)(d.Z,{id:t.title,className:c,children:[(0,D.jsxs)(h.Z,{disableSpacing:!0,children:[(0,D.jsx)(f.Z,{onClick:S,disableTypography:!0,title:(0,D.jsx)(y.x,{variant:"h6",bold:!0,children:t.title}),sx:{flexGrow:1,textAlign:"left"}}),t.launch&&(0,D.jsx)(g.E,{onClick:function(){return function(e){return T.apply(this,arguments)}(t.code)},title:"Try",children:(0,D.jsx)(b.Z,{})}),"native"===t.type?(0,D.jsx)(g.E,{title:"Mobile",children:(0,D.jsx)(m.Z,{})}):"web"===t.type?(0,D.jsx)(g.E,{title:"Web",children:(0,D.jsx)(p.Z,{})}):null,(0,D.jsx)(C,{onClick:S,expand:w,"aria-expanded":w,"aria-label":"show more",children:(0,D.jsx)(v.Z,{})})]}),(0,D.jsx)(L,{item:t,expanded:w})]})})}},12059:function(e,t,n){n.d(t,{W:function(){return c}});n(28381);var o="LayoutWithSideMenu_container__-IJo-",a="LayoutWithSideMenu_subContainer__Qh2t1",r="LayoutWithSideMenu_right__iV2Si",i=n(54622),s=n(29343),c=function(e){var t=e.Left,n=e.Right,c=(0,i.Z)("(max-width: 500px)");return(0,s.jsx)("div",{className:o,children:(0,s.jsxs)("div",{className:a,children:[(0,s.jsx)("div",{style:{width:c?"90%":"80%",display:"flex",flexDirection:"column"},children:(0,s.jsx)(t,{})}),!c&&(0,s.jsx)("div",{className:r,children:(0,s.jsx)(n,{})})]})})}},53870:function(e,t,n){n.d(t,{f:function(){return l}});n(28381);var o="SideMenu_container__HlxYD",a="SideMenu_item__B3q02",r="SideMenu_link__enMRA",i=n(7023),s=n(65571),c=n(94885),u=n(29343),l=function(e){var t=e.items;return(0,u.jsxs)("div",{className:o,children:[(0,u.jsx)(i.x,{variant:"h6",children:" On This Page"}),t.map((function(e,t){return(0,u.jsx)("div",{className:a,children:(0,u.jsx)(s.Z,{className:r,onClick:function(){return(0,c.X)({id:e,withHighlight:!0})},children:e})},e+t)}))]})}},54808:function(e,t,n){n.d(t,{EM:function(){return o},HB:function(){return a},f3:function(){return r}});var o=[{title:"useNetworkStatus",launch:!0,type:"web",desc:"A piece of state that tracks whether the network is online.\n    An Effect that subscribes to the global online and offline events, and updates that state.\n    This will keep your component synchronized with the network status.",code:'import { useState, useEffect } from "react";\n\nexport function useNetworkStatus(): boolean {\n  const [isOnline, setIsOnline] = useState<boolean>(true);\n  useEffect(() => {\n    function handleOnline() {\n      setIsOnline(true);\n    }\n    function handleOffline() {\n      setIsOnline(false);\n    }\n    window.addEventListener("online", handleOnline);\n    window.addEventListener("offline", handleOffline);\n    return () => {\n      window.removeEventListener("online", handleOnline);\n      window.removeEventListener("offline", handleOffline);\n    };\n  }, []);\n\n  return isOnline;\n}\n\nfunction App() {\n  const isOnline = useNetworkStatus();\n  return <h1>{isOnline ? "\u2705 Online" : "\u274c Disconnected"}</h1>;\n}\n\nexport default App;'},{title:"useDebouncedEffect",launch:!0,type:"web",desc:"The useDebouncedEffect hook is a custom hook that allows you to create an effect that is debounced. This means that the effect will only run after a certain delay has passed since the last update to its dependencies.",code:'import { useEffect, useState } from "react";\n\nexport const useDebouncedEffect = (\n  effect: () => void,\n  deps: any,\n  delay: number\n) => {\n  useEffect(() => {\n    const handler = setTimeout(() => effect(), delay);\n    return () => clearTimeout(handler);\n  }, [...(deps || []), delay]);\n};\n\nfunction App() {\n  const [searchTerm, setSearchTerm] = useState("");\n\n  useDebouncedEffect(\n    () => {\n      // Make an API call with the debounced search term\n      console.log("Search:", searchTerm);\n    },\n    [searchTerm],\n    5000 // Debounce delay of 5000ms\n  );\n\n  return (\n    <input\n      type="text"\n      value={searchTerm}\n      onChange={(e) => setSearchTerm(e.target.value)}\n    />\n  );\n}\n\nexport default App;\n'},{title:"useMediaQuery",launch:!0,type:"web",desc:'This is a custom React hook called "useMediaQuery" that takes in a query string and returns a boolean indicating whether the current viewport matches the specified media query. The hook uses the useState and useEffect hooks to update the matches state and register a listener for changes in viewport size.',code:'import { useState, useEffect } from "react";\n\nexport const useMediaQuery = (query: string) => {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    const media = window.matchMedia(query);\n    if (media.matches !== matches) {\n      setMatches(media.matches);\n    }\n    const listener = () => setMatches(media.matches);\n    window.addEventListener("resize", listener);\n    return () => window.removeEventListener("resize", listener);\n  }, [matches, query]);\n\n  return matches;\n};\n\nfunction App() {\n  const isSmallScreen:boolean = useMediaQuery("(max-width: 500px)");\n\n  return <p>{isSmallScreen.toString()}</p>;\n}\n\nexport default App;\n'},{title:"useToggle",launch:!0,type:"web",desc:'This is a custom React hook called "useToggle" that takes in an optional boolean initial state and returns a tuple with the current boolean state and a function to toggle the state. The hook uses the useState hook to initialize and update the state, and the useCallback hook to memoize the toggle function to prevent unnecessary re-renders. In the example usage, the hook is used to toggle a boolean value with a button click.',code:"import { useCallback, useState } from 'react';\n\n// Hook\n// Parameter is the boolean, with default \"false\" value\nconst useToggle = (initialState: boolean = false): [boolean, any] => {\n  const [state, setState] = useState<boolean>(initialState);\n  // Define and memorize toggler function in case we pass down the component,\n  // This function changes the boolean value to its opposite value\n  const toggle = useCallback((): void => setState(state => !state), []);\n  return [state, toggle]\n}\n\nfunction App() {\n  // Call the hook which returns the current value and the toggler function\n  const [isTextChanged, setIsTextChanged] = useToggle();\n  return (\n    <button onClick={setIsTextChanged}>{isTextChanged ? 'Toggled' : 'Click to Toggle'}</button>\n  );\n}\n\nexport default App"},{title:"useLocalStorage",launch:!0,type:"web",desc:"This hook takes in a key and initial value and returns an array with two values: the current value stored in local storage and a function to update the value. The hook uses the useState and useEffect hooks to get and set the value in local storage.",code:'import { useState, useEffect } from "react";\n\nexport const useLocalStorage = <T extends unknown>(\n  key: string,\n  initialValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] => {\n  const [value, setValue] = useState<T>(() => {\n    const storedValue = localStorage.getItem(key);\n    return storedValue !== null ? JSON.parse(storedValue) : initialValue;\n  });\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue];\n};\n\nfunction App() {\n  const [value, setValue] = useLocalStorage<string>("key", "value");\n\n  return <p onClick={() => setValue("new value")}>{value}</p>;\n}\n\nexport default App;\n'},{title:"useCopyToClipboard",launch:!0,type:"web",desc:'The useCopyToClipboard hook can be used in any React functional component to enable copying text to the clipboard and displaying the result of the copy operation to the user. *The "navigator.clipboard.writeText" method is only available over HTTPS or localhost.',code:"import { useState } from 'react'\n\ntype CopiedValue = string | null\ntype CopyFn = (text: string) => Promise<boolean> // Return success\n\nfunction useCopyToClipboard(): [CopiedValue, CopyFn] {\n  const [copiedText, setCopiedText] = useState<CopiedValue>(null)\n\n  const copy: CopyFn = async text => {\n    if (!navigator?.clipboard) {\n      console.warn('Clipboard not supported')\n      return false\n    }\n\n    // Try to save to clipboard then save it in the state if worked\n    try {\n      await navigator.clipboard.writeText(text)\n      setCopiedText(text)\n      return true\n    } catch (error) {\n      console.warn('Copy failed', error)\n      setCopiedText(null)\n      return false\n    }\n  }\n\n  return [copiedText, copy]\n}\n\nfunction App() {\n  const [copiedText, copy] = useCopyToClipboard();\n  return (\n    <>\n      <p onClick={(e) => copy(\"copyText\")}>Click For Copy</p>\n      <p>{copiedText}</p>\n    </>\n  );\n}\nexport default App; \n"},{title:"usePrevious",launch:!0,type:"web",desc:"This hook can be useful when you need to compare the previous value of a prop or state variable with the current value to trigger some action or effect. By storing the previous value in a ref, you can compare it to the current value in a subsequent render cycle of the component.",code:"import { useEffect, useRef, useState } from 'react';\n\nexport const usePrevious = <K = any>(value: K) => {\n  const ref = useRef<K>();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n};\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const prevCount = usePrevious(count);\n\n  return (\n    <div>\n      <p>Current count: {count}</p>\n      <p>Previous count: {prevCount}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default App;\n"}],a=[{title:"useInternetConnection",type:"native",desc:"This hook uses the NetInfo module to check the device's internet connectivity status. It sets the initial state to true and then listens for changes in the connectivity status using the useEffect hook. When the connectivity status changes, it updates the state accordingly.",code:"import { useState, useEffect } from 'react';\nimport NetInfo from '@react-native-community/netinfo';\n\nexport function useInternetConnection() {\n  const [isConnected, setIsConnected] = useState(true);\n\n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(state => {\n      setIsConnected(state.isConnected);\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return isConnected;\n}"},{title:"useIsForeground",type:"native",desc:"The useIsForeground hook is a custom hook that is used in a React Native application to detect if the app is currently in the foreground or not. It uses the AppState module from react-native to listen for changes in the app state and updates its own state accordingly.\n\n    The hook returns a boolean value indicating whether the app is currently in the foreground or not.",code:"import { useEffect, useState } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\n\nexport const useIsForeground = (): boolean => {\n  const [isForeground, setIsForeground] = useState(true);\n\n  useEffect(() => {\n    const onChange = (state: AppStateStatus): void => {\n      setIsForeground(state === 'active');\n    };\n    const listener = AppState.addEventListener('change', onChange);\n    return () => {\n      listener.remove();\n    };\n  }, [setIsForeground]);\n\n  return isForeground;\n};\n"},{title:"useKeyBoardStatus",type:"native",desc:"The useKeyBoardStatus hook is a custom hook that is used in a React Native application to detect the status of the keyboard. It uses the Keyboard module from react-native to listen for events when the keyboard is shown or hidden.\n    The hook returns an object with a boolean value called keyboardStatus, which is true if the keyboard is currently shown and false if it is hidden.",code:"import { useEffect, useState } from 'react';\nimport { Keyboard } from 'react-native';\n\nconst useKeyBoardStatus = () => {\n  const [keyboardStatus, setKeyboardStatus] = useState(false);\n  useEffect(() => {\n    const showSubscription = Keyboard.addListener('keyboardDidShow', () => {\n      setKeyboardStatus(true);\n    });\n    const hideSubscription = Keyboard.addListener('keyboardDidHide', () => {\n      setKeyboardStatus(false);\n    });\n    return () => {\n      showSubscription.remove();\n      hideSubscription.remove();\n    };\n  }, []);\n  return { keyboardStatus };\n};\n\nexport default useKeyBoardStatus;\n"},{title:"useBackButton",type:"native",desc:"This code defines a custom hook useBackButton that allows a developer to define a callback function that will be executed when the Android device's back button is pressed. The hook uses the useNavigation hook from the @react-navigation/native library to determine if the current screen is focused. If it is, the callback function is called, and true is returned to indicate that the back button press has been handled. If the screen is not focused, false is returned to allow the default back button behavior to occur.",code:"import React from 'react';\nimport { useNavigation } from '@react-navigation/native';\nimport { BackHandler } from 'react-native';\n\nconst useBackButton = (callBack?: () => void) => {\n  const nav = useNavigation();\n  React.useEffect(() => {\n    const backAction = () => {\n      if (nav.isFocused()) {\n        callBack?.();\n        return true;\n      }\n      return false;\n    };\n    const backHandler = BackHandler.addEventListener(\n      'hardwareBackPress',\n      backAction\n    );\n    return () => backHandler.remove();\n  }, [nav, callBack]);\n};\n\nexport default useBackButton;\n"},{title:"useDarkModeListener",type:"native",desc:"This code exports a custom hook called useDarkModeListener that takes an optional callback function. The hook uses the useEffect hook to listen for changes in the appearance mode (light or dark) of the app using the Appearance API provided by react-native. When the appearance mode changes, the callback function is called with a boolean value indicating whether the new mode is dark or not.",code:"import { useEffect } from 'react';\nimport { Appearance } from 'react-native';\n\nconst useDarkModeListener = (callBack?: (isDark: boolean) => void) => {\n  useEffect(() => {\n    const subscription = Appearance.addChangeListener(\n      ({ colorScheme: newColorScheme }) => {\n        callBack?.(newColorScheme === 'dark');\n      }\n    );\n\n    return () => subscription.remove();\n  }, [callBack]);\n};\n\nexport default useDarkModeListener;\n"},{title:"useOrientation",type:"native",desc:"This hook uses the Dimensions module to get the window dimensions and determine the current orientation. It sets the initial orientation based on the window dimensions and then listens for changes in the window dimensions using the useEffect hook. When the dimensions change, it updates the orientation accordingly.",code:"import { useState, useEffect } from 'react';\nimport { Dimensions } from 'react-native';\n\nexport function useOrientation() {\n  const [orientation, setOrientation] = useState(\n    Dimensions.get('window').width > Dimensions.get('window').height ? 'landscape' : 'portrait'\n  );\n\n  useEffect(() => {\n    const updateOrientation = () => {\n      setOrientation(\n        Dimensions.get('window').width > Dimensions.get('window').height ? 'landscape' : 'portrait'\n      );\n    };\n\n    Dimensions.addEventListener('change', updateOrientation);\n\n    return () => {\n      Dimensions.removeEventListener('change', updateOrientation);\n    };\n  }, []);\n\n  return orientation;\n}"}],r='\nimport React from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./src/App";\n\nconst root = ReactDOM.createRoot(\n  document.getElementById("root") as HTMLElement\n);\nroot.render(<App />);\n\n'},83579:function(e,t,n){n.d(t,{EK:function(){return p},jN:function(){return v},M8:function(){return b},_D:function(){return h},a2:function(){return m}});var o=n(1413),a=n(34108),r=n(4942),i=n(29439),s=n(15861),c=(n(31319),n(16811)),u=n(62257),l=n(45011),d={addTab:"Tab added successfully",removeTab:"Tab removed successfully",deleteCollection:"Collection deleted successfully"},h=function(e){return e.res.response=null,e.res.error=null,e.res.errorMessage=null,e.res.size=null,e.res.time=null,e},f=function(e,t){u.I8.currentUser?t(u.db.collection("users").doc(u.I8.currentUser.email)).then((function(){return l.Am.success(d[e])})).catch((function(){return l.Am.error("Operation failed")})):l.Am.error("Please logged in order to save your work.")},p=function(e){f("deleteCollection",function(){var t=(0,s.Z)((0,a.Z)().mark((function t(n){var o,s,u,l;return(0,a.Z)().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.get();case 2:if(!(o=t.sent).exists){t.next=8;break}return u=(null===(s=o.data())||void 0===s?void 0:s.api)||{},l=[],Object.entries(u).forEach((function(t){var o=(0,i.Z)(t,2),a=o[0];o[1].collection===e&&l.push(n.update((0,r.Z)({},"api.".concat(a),c.Z.firestore.FieldValue.delete())))})),t.abrupt("return",Promise.all(l));case 8:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}())},m=function(e,t){f("addTab",(function(n){var a=(0,r.Z)({},"api",(0,r.Z)({},"".concat(e),(0,o.Z)({},h(t))));return n.set(a,{merge:!0})}))},v=function(e){f("removeTab",(function(t){var n=(0,r.Z)({},"api.".concat(e),c.Z.firestore.FieldValue.delete());return t.update(n)}))},b=function(e){return new Promise((function(t,n){var o=u.db.collection("users").doc(e);o.get().then((function(e){var n,a;e.exists?t(null!==(n=null===(a=e.data())||void 0===a?void 0:a.api)&&void 0!==n?n:{}):o.set({sections:{}}).then((function(){return t({})}))})).catch(n)}))}},52903:function(e,t,n){n.d(t,{$9:function(){return i},Ap:function(){return s},Y5:function(){return l},ZO:function(){return r},rZ:function(){return c},ts:function(){return u}});var o=n(29439),a=n(83579);function r(e){if(!e||"string"!==typeof e)return"Invalid JSON";for(var t="",n=0,o=!1,a=0;a<e.length;a++){var r=e[a];if(o)t+=r,'"'===r&&"\\"!==e[a-1]&&(o=!1);else switch(r){case"{":case"[":t+=r+"\n"+" ".repeat(2*(n+1)),n++;break;case"}":case"]":n=Math.max(0,n-1),t+="\n"+" ".repeat(2*n)+r;break;case":":t+=r+" ";break;case",":t+=r+"\n"+" ".repeat(2*n);break;case'"':t+=r,o=!0;break;default:t+=r}}return t}var i=function(e){return e.map((function(e,t){return e.title}))},s=function(e){return Object.fromEntries(Object.entries(e).filter((function(e){var t=(0,o.Z)(e,2),n=(t[0],t[1]);return""!==n.value&&(void 0===n.checked||n.checked)})).map((function(e){var t=(0,o.Z)(e,2),n=(t[0],t[1]);return[n.key,n.value]})))};function c(e){var t=0;for(var n in e)e.hasOwnProperty(n)&&e[n].checked&&t++;return t}function u(e,t){for(var n in e)if(e.hasOwnProperty(n)&&e[n].collection===t)return e[n].id}var l=function(e,t){var n=JSON.parse(JSON.stringify(e)),o=JSON.parse(JSON.stringify(t));return JSON.stringify((0,a._D)(n))!==JSON.stringify((0,a._D)(o))}},94885:function(e,t,n){n.d(t,{X:function(){return o}});var o=function(e){var t=e.id,n=e.behavior,o=void 0===n?"smooth":n,a=e.block,r=void 0===a?"start":a,i=e.withHighlight,s=void 0!==i&&i,c=document.getElementById(t);c&&(c.scrollIntoView({behavior:o,block:r}),s&&(c.classList.add("custom-highlighted-class"),setTimeout((function(){c&&c.classList.remove("custom-highlighted-class")}),3e3)))}}}]);
//# sourceMappingURL=890.420c3e0c.chunk.js.map